/**
 * Correction Generator Component
 * Generates spec file corrections based on error analysis
 *
 * This component:
 * 1. Uses LLM to analyze error and suggest fix
 * 2. Generates updated spec file content
 * 3. Validates correction doesn't break other requirements
 *
 * Requirements: 5.2, 5.3
 */

import type { ErrorContext, ParsedSpec } from '@/types/spec';
import type { ErrorAnalysis } from './error-analyzer';
import { readFile } from 'fs/promises';
import { join } from 'path';

/**
 * Correction plan generated by the correction generator
 */
export interface CorrectionPlan {
  /** Type of error being corrected */
  errorType: string;

  /** Which spec file to update */
  targetFile: string;

  /** Description of the correction */
  correction: string;

  /** Updated file content */
  updatedContent: string;

  /** Current attempt number (1-3) */
  attemptNumber: number;

  /** Confidence level in the correction (0-100) */
  confidence: number;
}

/**
 * Options for generating corrections
 */
export interface CorrectionOptions {
  /** Path to the spec directory */
  specPath: string;

  /** Current attempt number (1-3) */
  attemptNumber: number;

  /** Parsed spec for validation */
  parsedSpec?: ParsedSpec;
}

/**
 * Correction Generator generates spec file corrections based on error analysis
 *
 * Responsibilities:
 * - Analyze error context and error analysis
 * - Generate appropriate corrections for spec files
 * - Validate corrections don't break other requirements
 * - Produce updated spec file content
 *
 * **Validates: Requirements 5.2, 5.3**
 */
export class CorrectionGenerator {
  /**
   * Generates a correction plan based on error analysis
   *
   * Algorithm:
   * 1. Read current spec file content
   * 2. Analyze error and determine correction strategy
   * 3. Generate updated content (using LLM in future)
   * 4. Validate correction doesn't break other requirements
   * 5. Return correction plan
   *
   * @param error - Error context from failed task
   * @param analysis - Error analysis from ErrorAnalyzer
   * @param options - Correction options
   * @returns Correction plan with updated content
   *
   * **Validates: Requirements 5.2, 5.3**
   */
  async generateCorrection(
    error: ErrorContext,
    analysis: ErrorAnalysis,
    options: CorrectionOptions
  ): Promise<CorrectionPlan> {
    // Step 1: Read current spec file content
    const currentContent = await this.readSpecFile(options.specPath, analysis.targetFile);

    // Step 2: Generate correction based on error type
    const correction = await this.generateCorrectionText(error, analysis, currentContent);

    // Step 3: Generate updated content
    const updatedContent = await this.generateUpdatedContent(
      currentContent,
      correction,
      error,
      analysis
    );

    // Step 4: Validate correction
    const validationResult = await this.validateCorrection(
      updatedContent,
      analysis.targetFile,
      options.parsedSpec
    );

    if (!validationResult.isValid) {
      throw new Error(`Correction validation failed: ${validationResult.errors.join(', ')}`);
    }

    // Step 5: Return correction plan
    return {
      errorType: analysis.errorType,
      targetFile: analysis.targetFile,
      correction,
      updatedContent,
      attemptNumber: options.attemptNumber,
      confidence: analysis.confidence,
    };
  }

  /**
   * Reads the current spec file content
   *
   * @param specPath - Path to spec directory
   * @param targetFile - Which spec file to read
   * @returns File content as string
   */
  private async readSpecFile(specPath: string, targetFile: string): Promise<string> {
    const filePath = join(specPath, targetFile);
    try {
      return await readFile(filePath, 'utf-8');
    } catch (error) {
      throw new Error(
        `Failed to read spec file ${targetFile}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  /**
   * Generates correction text based on error analysis
   *
   * This method will use LLM in the future. For now, it generates
   * rule-based corrections based on error type.
   *
   * @param error - Error context
   * @param analysis - Error analysis
   * @param currentContent - Current spec file content
   * @returns Correction description
   */
  private async generateCorrectionText(
    error: ErrorContext,
    analysis: ErrorAnalysis,
    currentContent: string
  ): Promise<string> {
    // TODO: Replace with LLM-based correction generation
    // For now, use rule-based approach

    const { errorType } = analysis;

    switch (errorType) {
      case 'test_failure':
        return this.generateTestFailureCorrection(error, analysis, currentContent);

      case 'compilation_error':
        return this.generateCompilationErrorCorrection(error, analysis, currentContent);

      case 'runtime_error':
        return this.generateRuntimeErrorCorrection(error, analysis, currentContent);

      case 'missing_dependency':
        return this.generateMissingDependencyCorrection(error, analysis, currentContent);

      case 'invalid_spec':
        return this.generateInvalidSpecCorrection(error, analysis, currentContent);

      case 'timeout_error':
        return this.generateTimeoutErrorCorrection(error, analysis, currentContent);

      default:
        return this.generateGenericCorrection(error, analysis, currentContent);
    }
  }

  /**
   * Generates correction for test failures
   */
  private generateTestFailureCorrection(
    _error: ErrorContext,
    analysis: ErrorAnalysis,
    _currentContent: string
  ): string {
    const { rootCause, context } = analysis;

    // Check if this is a property test failure
    if (context.propertyRef) {
      return `Adjust ${context.propertyRef} in design.md to handle the failing case: ${rootCause}. The property may be too strict or need additional constraints.`;
    }

    // Regular test failure
    return `Update design.md to clarify the expected behavior for: ${rootCause}. Add implementation notes or adjust the design to handle this case.`;
  }

  /**
   * Generates correction for compilation errors
   */
  private generateCompilationErrorCorrection(
    _error: ErrorContext,
    analysis: ErrorAnalysis,
    _currentContent: string
  ): string {
    const { rootCause } = analysis;

    return `Add missing type definitions or interfaces to design.md to resolve: ${rootCause}. Include complete type signatures and interface definitions.`;
  }

  /**
   * Generates correction for runtime errors
   */
  private generateRuntimeErrorCorrection(
    error: ErrorContext,
    analysis: ErrorAnalysis,
    _currentContent: string
  ): string {
    const { rootCause } = analysis;

    return `Add implementation guidance to tasks.md for task ${error.taskId} to prevent: ${rootCause}. Include null checks, validation steps, or error handling instructions.`;
  }

  /**
   * Generates correction for missing dependencies
   */
  private generateMissingDependencyCorrection(
    _error: ErrorContext,
    analysis: ErrorAnalysis,
    _currentContent: string
  ): string {
    const { rootCause } = analysis;

    // Extract module name from root cause
    const moduleMatch = rootCause.match(/Missing module: "(.+?)"/);
    const moduleName = moduleMatch ? moduleMatch[1] : 'unknown module';

    return `Add a requirement in requirements.md for the missing dependency: ${moduleName}. Specify its purpose and how it should be used.`;
  }

  /**
   * Generates correction for invalid spec
   */
  private generateInvalidSpecCorrection(
    _error: ErrorContext,
    analysis: ErrorAnalysis,
    _currentContent: string
  ): string {
    const { rootCause } = analysis;

    return `Fix the specification syntax error: ${rootCause}. Ensure all markdown formatting is correct and all references are valid.`;
  }

  /**
   * Generates correction for timeout errors
   */
  private generateTimeoutErrorCorrection(
    error: ErrorContext,
    analysis: ErrorAnalysis,
    _currentContent: string
  ): string {
    const { rootCause } = analysis;

    return `Add performance optimization guidance to tasks.md for task ${error.taskId}: ${rootCause}. Consider adding caching, pagination, or async processing strategies.`;
  }

  /**
   * Generates generic correction
   */
  private generateGenericCorrection(
    error: ErrorContext,
    analysis: ErrorAnalysis,
    _currentContent: string
  ): string {
    const { rootCause } = analysis;

    return `Add clarification to tasks.md for task ${error.taskId} to address: ${rootCause}. Provide additional context or implementation guidance.`;
  }

  /**
   * Generates updated spec file content with the correction applied
   *
   * This method performs surgical updates - it only modifies the relevant
   * section while preserving all other content.
   *
   * @param currentContent - Current spec file content
   * @param correction - Correction description
   * @param error - Error context
   * @param analysis - Error analysis
   * @returns Updated file content
   *
   * **Validates: Requirement 5.3**
   */
  private async generateUpdatedContent(
    currentContent: string,
    correction: string,
    error: ErrorContext,
    analysis: ErrorAnalysis
  ): Promise<string> {
    const { targetFile } = analysis;

    switch (targetFile) {
      case 'design.md':
        return this.updateDesignFile(currentContent, correction, error, analysis);

      case 'requirements.md':
        return this.updateRequirementsFile(currentContent, correction, error, analysis);

      case 'tasks.md':
        return this.updateTasksFile(currentContent, correction, error, analysis);

      default:
        throw new Error(`Unknown target file: ${targetFile}`);
    }
  }

  /**
   * Updates design.md with correction
   *
   * Strategy: Add a note to the relevant property or add a new section
   */
  private updateDesignFile(
    currentContent: string,
    correction: string,
    error: ErrorContext,
    analysis: ErrorAnalysis
  ): string {
    const { context } = analysis;

    // If we have a property reference, add note to that property
    if (context.propertyRef) {
      return this.addNoteToProperty(currentContent, context.propertyRef, correction);
    }

    // Otherwise, add a note to the Error Handling section
    return this.addNoteToSection(
      currentContent,
      '## Error Handling',
      `### Correction for Task ${error.taskId}\n\n${correction}\n\n**Applied**: ${new Date().toISOString()}\n**Root Cause**: ${analysis.rootCause}`
    );
  }

  /**
   * Updates requirements.md with correction
   *
   * Strategy: Add a new acceptance criterion or add a new requirement
   */
  private updateRequirementsFile(
    currentContent: string,
    correction: string,
    error: ErrorContext,
    _analysis: ErrorAnalysis
  ): string {
    // Find the last requirement section
    const requirementPattern = /### Requirement \d+:/g;
    const matches = Array.from(currentContent.matchAll(requirementPattern));

    if (matches.length === 0) {
      // No requirements yet, add first one
      return `${currentContent}\n\n### Requirement 1: Address ${error.taskId} Error\n\n**User Story:** As a developer, I want the system to handle the error case discovered in task ${error.taskId}.\n\n#### Acceptance Criteria\n\n1. ${correction}\n`;
    }

    // Add a new requirement after the last one
    const lastMatch = matches[matches.length - 1];
    if (!lastMatch) {
      return `${currentContent}\n\n### Requirement 1: Address ${error.taskId} Error\n\n**User Story:** As a developer, I want the system to handle the error case discovered in task ${error.taskId}.\n\n#### Acceptance Criteria\n\n1. ${correction}\n`;
    }

    const lastRequirementNumber = parseInt(lastMatch[0].match(/\d+/)?.[0] || '0', 10);
    const newRequirementNumber = lastRequirementNumber + 1;

    // Find the end of the last requirement (next ## header or end of file)
    const lastRequirementIndex = lastMatch.index || 0;
    const nextSectionMatch = currentContent.slice(lastRequirementIndex + 1).match(/\n## /);
    const insertIndex = nextSectionMatch
      ? lastRequirementIndex + 1 + nextSectionMatch.index!
      : currentContent.length;

    const newRequirement = `\n### Requirement ${newRequirementNumber}: Address ${error.taskId} Error\n\n**User Story:** As a developer, I want the system to handle the error case discovered in task ${error.taskId}.\n\n#### Acceptance Criteria\n\n1. ${correction}\n`;

    return (
      currentContent.slice(0, insertIndex) + newRequirement + currentContent.slice(insertIndex)
    );
  }

  /**
   * Updates tasks.md with correction
   *
   * Strategy: Add a note to the failed task
   */
  private updateTasksFile(
    currentContent: string,
    correction: string,
    error: ErrorContext,
    _analysis: ErrorAnalysis
  ): string {
    // Find the task by ID
    const taskPattern = new RegExp(
      `^(\\s*- \\[[\\s~>x]\\]\\*?\\s+${error.taskId.replace(/\./g, '\\.')}\\s+.+)$`,
      'gm'
    );

    const match = taskPattern.exec(currentContent);

    if (!match) {
      // Task not found, add note at the end
      return `${currentContent}\n\n## Corrections\n\n### Task ${error.taskId}\n\n${correction}\n\n**Applied**: ${new Date().toISOString()}\n`;
    }

    // Add note after the task line
    const taskLine = match[0];
    const taskIndex = match.index;
    const afterTaskIndex = taskIndex + taskLine.length;

    // Check if there's already a note for this task
    const notePattern = /\n\s+_Note: .+_/;
    const existingNote = currentContent.slice(afterTaskIndex).match(notePattern);

    if (existingNote) {
      // Replace existing note
      const noteIndex = afterTaskIndex + existingNote.index!;
      const noteEnd = noteIndex + existingNote[0].length;

      return (
        currentContent.slice(0, noteIndex) +
        `\n    _Note: ${correction}_` +
        currentContent.slice(noteEnd)
      );
    }

    // Add new note
    return (
      currentContent.slice(0, afterTaskIndex) +
      `\n    _Note: ${correction}_` +
      currentContent.slice(afterTaskIndex)
    );
  }

  /**
   * Adds a note to a specific property in design.md
   */
  private addNoteToProperty(content: string, propertyRef: string, note: string): string {
    // Find the property section
    const propertyPattern = new RegExp(
      `(\\*\\*${propertyRef}:.+?\\*\\*)([\\s\\S]+?)(?=\\n\\*\\*Property|\\n## |$)`,
      'i'
    );

    const match = propertyPattern.exec(content);

    if (!match) {
      // Property not found, add note at the end
      return `${content}\n\n## Corrections\n\n### ${propertyRef}\n\n${note}\n`;
    }

    // Add note at the end of the property section
    const propertyEnd = match.index + match[0].length;

    return content.slice(0, propertyEnd) + `\n\n**Note**: ${note}\n` + content.slice(propertyEnd);
  }

  /**
   * Adds a note to a specific section in the spec file
   */
  private addNoteToSection(content: string, sectionHeader: string, note: string): string {
    // Find the section
    const sectionPattern = new RegExp(`(${sectionHeader})([\\s\\S]+?)(?=\\n## |$)`, 'i');

    const match = sectionPattern.exec(content);

    if (!match) {
      // Section not found, add at the end
      return `${content}\n\n${sectionHeader}\n\n${note}\n`;
    }

    // Add note at the end of the section
    const sectionEnd = match.index + match[0].length;

    return content.slice(0, sectionEnd) + `\n\n${note}\n` + content.slice(sectionEnd);
  }

  /**
   * Validates that the correction doesn't break other requirements
   *
   * Validation checks:
   * 1. Markdown syntax is valid
   * 2. All requirement references still exist
   * 3. All property references still exist
   * 4. No duplicate IDs introduced
   *
   * @param updatedContent - Updated spec file content
   * @param targetFile - Which spec file was updated
   * @param parsedSpec - Parsed spec for validation (optional)
   * @returns Validation result
   */
  private async validateCorrection(
    updatedContent: string,
    targetFile: string,
    parsedSpec?: ParsedSpec
  ): Promise<{ isValid: boolean; errors: string[] }> {
    const errors: string[] = [];

    // Basic validation: check that content is not empty
    if (!updatedContent || updatedContent.trim().length === 0) {
      errors.push('Updated content is empty');
      return { isValid: false, errors };
    }

    // Validate markdown structure
    const markdownErrors = this.validateMarkdownStructure(updatedContent, targetFile);
    errors.push(...markdownErrors);

    // If we have parsed spec, validate references
    if (parsedSpec) {
      const referenceErrors = this.validateReferences(updatedContent, targetFile, parsedSpec);
      errors.push(...referenceErrors);
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  /**
   * Validates markdown structure
   */
  private validateMarkdownStructure(content: string, targetFile: string): string[] {
    const errors: string[] = [];

    // Check for basic markdown structure based on file type
    switch (targetFile) {
      case 'requirements.md':
        // Should have at least one requirement section
        if (!/### Requirement \d+:/i.test(content)) {
          errors.push('requirements.md must contain at least one requirement section');
        }
        break;

      case 'design.md':
        // Should have at least one major section
        if (!/## \w+/i.test(content)) {
          errors.push('design.md must contain at least one major section');
        }
        break;

      case 'tasks.md':
        // Should have at least one task
        if (!/- \[[^\]]\]\*?\s+[\d.]+\s+/i.test(content)) {
          errors.push('tasks.md must contain at least one task');
        }
        break;
    }

    return errors;
  }

  /**
   * Validates references in the updated content
   */
  private validateReferences(
    content: string,
    _targetFile: string,
    parsedSpec: ParsedSpec
  ): string[] {
    const errors: string[] = [];

    // Extract requirement references from content
    const requirementRefs = Array.from(
      content.matchAll(/Requirements?\s+([\d.]+(?:,\s*[\d.]+)*)/gi)
    );

    for (const match of requirementRefs) {
      if (match[1]) {
        const refs = match[1].split(',').map((r) => r.trim());
        for (const ref of refs) {
          const exists = parsedSpec.requirements.some((req) => req.id === ref);
          if (!exists) {
            errors.push(`Referenced requirement ${ref} does not exist`);
          }
        }
      }
    }

    // Extract property references from content
    const propertyRefs = Array.from(content.matchAll(/Property\s+(\d+)/gi));

    for (const match of propertyRefs) {
      if (match[1]) {
        const propNum = parseInt(match[1], 10);
        const exists = parsedSpec.properties.some((prop) => prop.number === propNum);
        if (!exists) {
          errors.push(`Referenced property ${propNum} does not exist`);
        }
      }
    }

    return errors;
  }
}

/**
 * Creates a correction generator instance
 *
 * @returns CorrectionGenerator instance
 */
export function createCorrectionGenerator(): CorrectionGenerator {
  return new CorrectionGenerator();
}
